% This file was created with Citavi 6.3.0.0

@book{Gamma.1995,
 author = {Gamma, Erich},
 year = {1995},
 title = {Design patterns: Elements of reusable object-oriented software /   Erich Gamma ... [et al.]},
 address = {Reading, Mass. and Wokingham},
 publisher = {Addison-Wesley},
 isbn = {0201633612},
 series = {Addison-Wesley professional computing series}
}


@book{Johnson.2003,
 author = {Johnson, Rod},
 year = {2003},
 title = {Expert one-on-one J2EE design and development},
 price = {{\pounds}43.99},
 address = {Indianapolis, Ind. and Great Britain},
 publisher = {Wrox},
 isbn = {0-7645-4385-7},
 series = {Programmer to programmer}
}


@misc{MartinFowler.23.01.2020,
 abstract = {Explaining the Dependency Injection pattern, by contrasting it with Service Locator. The choice between them is less important than the principle of separating configuration from use.},
 author = {{Martin Fowler}},
 year = {23.01.2020},
 title = {Inversion of Control Containers and the Dependency Injection pattern},
 url = {https://www.martinfowler.com/articles/injection.html#InversionOfControl},
 urldate = {23.01.2020}
}


@article{RoyThomasFielding.2000,
 author = {{Roy Thomas Fielding}},
 year = {2000},
 title = {Architectural Styles and the Design of Network-based Software Architectures},
 url = {https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf},
 urldate = {23.01.2020},
 file = {Untitled Document:C\:\\Users\\D070307\\workspace\\travlyn\\docs\\work\\content\\Citavi Attachments\\Untitled Document.pdf:pdf}
}


@misc{SmartBear.2020,
 abstract = {Swagger aides in development across the entire API lifecycle, from design and documentation, to test and deployment. Try it today!},
 author = {SmartBear},
 year = {2020},
 title = {The Best APIs are Built with Swagger Tools | Swagger},
 url = {https://swagger.io/},
 urldate = {23.01.2020}
}


@book{Spichale.2017,
 abstract = {{\textquotedbl}Vorwort{\textquotedbl} -- {\textquotedbl}Warum ist API-Design wichtig?{\textquotedbl} -- {\textquotedbl}Eine Frage der Perspektive{\textquotedbl} -- {\textquotedbl}Zielgruppe und Voraussetzungen{\textquotedbl} -- {\textquotedbl}Struktur des Buches{\textquotedbl} -- {\textquotedbl}Pfade durch das Buch{\textquotedbl} -- {\textquotedbl}Danksagung{\textquotedbl} -- {\textquotedbl}InhaltsÃ¼bersicht{\textquotedbl} -- {\textquotedbl}Inhaltsverzeichnis{\textquotedbl} -- {\textquotedbl}Teil  I â Grundlagen{\textquotedbl} -- {\textquotedbl}1 Application Programming Interfaces â eine EinfÃ¼hrung{\textquotedbl} -- {\textquotedbl}1.1 Eine kurze Geschichte der APIs{\textquotedbl} -- {\textquotedbl}1.2 Web-APIs ab dem Jahr 2000{\textquotedbl} -- {\textquotedbl}1.3 API-Definition{\textquotedbl} -- {\textquotedbl}Abb. 1â1 Es gibt verschiedene API-Typen. In diesem Buch werden objektorientierte Java-APIs, Web-APIs und Messaging-APIs behandelt.{\textquotedbl} -- {\textquotedbl}1.4 Vorteile einer API{\textquotedbl} -- {\textquotedbl}1.5 Nachteile einer API{\textquotedbl} -- {\textquotedbl}1.6 API als Produkt{\textquotedbl} -- {\textquotedbl}1.7 Welche Strategien verfolgen Unternehmen mit APIs?{\textquotedbl} -- {\textquotedbl}1.8 Zusammenfassung{\textquotedbl} -- {\textquotedbl}2 QualitÃ¤tsmerkmale{\textquotedbl} -- {\textquotedbl}2.1 Allgemeine QualitÃ¤tsmerkmale{\textquotedbl} -- {\textquotedbl}2.2 Benutzbarkeit{\textquotedbl} -- {\textquotedbl}2.2.1 Konsistent{\textquotedbl} -- {\textquotedbl}2.2.2 Intuitiv verstÃ¤ndlich{\textquotedbl} -- {\textquotedbl}2.2.3 Dokumentiert{\textquotedbl} -- {\textquotedbl}2.2.4 EinprÃ¤gsam und leicht zu lernen{\textquotedbl} -- {\textquotedbl}2.2.5 Lesbaren Code fÃ¶rdernd{\textquotedbl} -- {\textquotedbl}2.2.6 Schwer falsch zu benutzen{\textquotedbl} -- {\textquotedbl}2.2.7 Minimal{\textquotedbl} -- {\textquotedbl}Weniger ist manchmal mehr{\textquotedbl} -- {\textquotedbl}2.2.8 Stabil{\textquotedbl} -- {\textquotedbl}2.2.9 Einfach erweiterbar{\textquotedbl} -- {\textquotedbl}2.3 Zusammenfassung{\textquotedbl} -- {\textquotedbl}3 Allgemeines Vorgehen beim API-Design{\textquotedbl} -- {\textquotedbl}3.1 Ãberblick{\textquotedbl} -- {\textquotedbl}Abb. 3â1 Allgemeines Vorgehen beim API-Entwurf mit Feedbackschleifen{\textquotedbl} -- {\textquotedbl}3.2 Heuristiken und Trade-offs{\textquotedbl} -- {\textquotedbl}3.3 Anforderungen herausarbeiten{\textquotedbl} -- {\textquotedbl}3.4 Wenn Use Cases nicht ausreichen{\textquotedbl} -- {\textquotedbl}3.5 Entwurf mit Szenarien und Codebeispielen{\textquotedbl} -- {\textquotedbl}3.6 Spezifikation erstellen{\textquotedbl} -- {\textquotedbl}3.7 Reviews und Feedback{\textquotedbl} -- {\textquotedbl}BerÃ¼hmte API-Typos{\textquotedbl} -- {\textquotedbl}3.8 Wiederverwendung{\textquotedbl} -- {\textquotedbl}3.9 Zusammenfassung{\textquotedbl} -- {\textquotedbl}Teil II â Java-APIs{\textquotedbl} -- {\textquotedbl}4 AusprÃ¤gungen{\textquotedbl} -- {\textquotedbl}4.1 Implizite Objekt-API{\textquotedbl} -- {\textquotedbl}APIs nicht nur fÃ¼r Komponenten- und Teamgrenzen{\textquotedbl} -- {\textquotedbl}API-Design fÃ¶rdert Clean Code{\textquotedbl} -- {\textquotedbl}4.2 Utility-Bibliothek{\textquotedbl} -- {\textquotedbl}4.3 Service

{\textquotedbl}Abb. 4â1 In der Onion Architecture bilden die Application Services die API-Schicht des Application Core.{\textquotedbl} -- {\textquotedbl}Abb. 4â2 Die Applikation ist in Schichten und vertikale Schnitte eingeteilt. Die entstandenen Komponenten sind durch wohldefinierte Schnittstellen integriert.{\textquotedbl} -- {\textquotedbl}4.4 Framework{\textquotedbl} -- {\textquotedbl}4.5 Eine Frage der PrioritÃ¤t{\textquotedbl} -- {\textquotedbl}4.6 Zusammenfassung{\textquotedbl} -- {\textquotedbl}5 Grundlagen fÃ¼r Java-APIs{\textquotedbl} -- {\textquotedbl}5.1 Auswahl passender Namen{\textquotedbl} -- {\textquotedbl}5.1.1 Klassennamen{\textquotedbl} -- {\textquotedbl}5.1.2 Methodennamen{\textquotedbl} -- {\textquotedbl}Beschreibe alles, was die Methode macht!{\textquotedbl} -- {\textquotedbl}Vermeide bedeutungslose Verben!{\textquotedbl} -- {\textquotedbl}Ein Name ist so lang wie notwendig, aber nicht lÃ¤nger.{\textquotedbl} -- {\textquotedbl}Benenne Query-Methoden nach ihren RÃ¼ckgabewerten!{\textquotedbl} -- {\textquotedbl}Benenne Command-Methoden mit aussagekrÃ¤ftigen Verben!{\textquotedbl} -- {\textquotedbl}Nutze etablierte Begriffe!{\textquotedbl} -- {\textquotedbl}Nutze passende Antonyme!{\textquotedbl} -- {\textquotedbl}5.1.3 Parameternamen{\textquotedbl} -- {\textquotedbl}5.1.4 UbiquitÃ¤re Sprache{\textquotedbl} -- {\textquotedbl}5.1.5 Fazit{\textquotedbl} -- {\textquotedbl}5.2 Effektiver Einsatz von Typen{\textquotedbl} -- {\textquotedbl}5.2.1 Semantischen Vertrag minimieren{\textquotedbl} -- {\textquotedbl}5.2.2 Semantische Verletzung der Datenkapselung vermeiden{\textquotedbl} -- {\textquotedbl}5.2.3 Werden Namen Ã¼berschÃ¤tzt?{\textquotedbl} -- {\textquotedbl}5.2.4 Fazit{\textquotedbl} -- {\textquotedbl}5.3 Techniken fÃ¼r Objektkollaboration{\textquotedbl} -- {\textquotedbl}5.3.1 Tell, Donât Ask{\textquotedbl} -- {\textquotedbl}5.3.2 Command/Query Separation{\textquotedbl} -- {\textquotedbl}5.3.3 Law of Demeter{\textquotedbl} -- {\textquotedbl}5.3.4 Platzierung von Methoden{\textquotedbl} -- {\textquotedbl}5.3.5 Fazit{\textquotedbl} -- {\textquotedbl}5.4 Minimale Sichtbarkeit{\textquotedbl} -- {\textquotedbl}5.4.1 Packages{\textquotedbl} -- {\textquotedbl}5.4.2 Klassen{\textquotedbl} -- {\textquotedbl}5.4.3 Methoden{\textquotedbl} -- {\textquotedbl}5.4.4 Felder{\textquotedbl} -- {\textquotedbl}5.4.5 Fazit{\textquotedbl} -- {\textquotedbl}5.5 Optionale Hilfsmethoden{\textquotedbl} -- {\textquotedbl}5.5.1 Komfort{\textquotedbl} -- {\textquotedbl}5.5.2 Utility-Klassen{\textquotedbl} -- {\textquotedbl}5.5.3 Fazit{\textquotedbl} -- {\textquotedbl}5.6 Optionale RÃ¼ckgabewerte{\textquotedbl} -- {\textquotedbl}5.6.1 Ad-hoc-Fehlerbehandlung{\textquotedbl} -- {\textquotedbl}5.6.2 Null-Objekte{\textquotedbl} -- {\textquotedbl}5.6.3 Ergebnisobjekte{\textquotedbl} -- {\textquotedbl}5.6.4 Fazit{\textquotedbl} -- {\textquotedbl}5.7 Exceptions{\textquotedbl} -- {\textquotedbl}5.7.1 Ausnahmesituationen{\textquotedbl} -- {\textquotedbl}5.7.2 Checked Exception versus Unchecked Exception{\textquotedbl} -- {\textquotedbl}5.7.3 Passende Abstraktionen{\textquotedbl} -- {\textquotedbl}5.7.4 Dokumentation von Exceptions{\textquotedbl} -- {\textquotedbl}5.7.5 Vermeidung von Exceptions{\textquotedbl} -- {\textquotedbl}5.7.6 Fazit{\textquotedbl} -- {\textquotedbl}5.8 Objekterzeugung

{\textquotedbl}5.8.1 Erzeugungsmuster der GoF{\textquotedbl} -- {\textquotedbl}5.8.2 Statische Factory-Methode{\textquotedbl} -- {\textquotedbl}Konkrete Namen{\textquotedbl} -- {\textquotedbl}Wiederverwendung von Objekten{\textquotedbl} -- {\textquotedbl}Flexible Erzeugung von Subtypen{\textquotedbl} -- {\textquotedbl}5.8.3 Builder mit Fluent Interface{\textquotedbl} -- {\textquotedbl}5.8.4 Praktische Anwendung der Erzeugungsmuster{\textquotedbl} -- {\textquotedbl}Joda-Time Framework{\textquotedbl} -- {\textquotedbl}MongoDB Java Client{\textquotedbl} -- {\textquotedbl}5.8.5 Fazit{\textquotedbl} -- {\textquotedbl}5.9 Vererbung{\textquotedbl} -- {\textquotedbl}5.9.1 AnsÃ¤tze zum Einsatz von Vererbung{\textquotedbl} -- {\textquotedbl}Open Inheritance{\textquotedbl} -- {\textquotedbl}Designed Inheritance{\textquotedbl} -- {\textquotedbl}5.9.2 Stolperfallen bei Vererbung{\textquotedbl} -- {\textquotedbl}5.9.3 Bedeutung fÃ¼r API-Design{\textquotedbl} -- {\textquotedbl}Designed Inheritance fÃ¼r Eclipse-Plug-ins{\textquotedbl} -- {\textquotedbl}5.9.4 Fazit{\textquotedbl} -- {\textquotedbl}5.10 Interfaces{\textquotedbl} -- {\textquotedbl}5.10.1 Typen nachrÃ¼sten{\textquotedbl} -- {\textquotedbl}5.10.2 UnterstÃ¼tzung fÃ¼r nicht triviale Interfaces{\textquotedbl} -- {\textquotedbl}5.10.3 Markierungsschnittstellen{\textquotedbl} -- {\textquotedbl}5.10.4 Funktionale Interfaces{\textquotedbl} -- {\textquotedbl}5.10.5 Fazit{\textquotedbl} -- {\textquotedbl}5.11 Zusammenfassung{\textquotedbl} -- {\textquotedbl}6 Fortgeschrittene Techniken fÃ¼r Java-APIs{\textquotedbl} -- {\textquotedbl}6.1 Fluent Interface{\textquotedbl} -- {\textquotedbl}6.1.1 DSL-Grammatik{\textquotedbl} -- {\textquotedbl}Abb. 6â1 Das Syntaxdiagramm ist eine grafische ReprÃ¤sentation der EBNF und wurde mit http://www.bottlecaps.de/ rr/ui erstellt.{\textquotedbl} -- {\textquotedbl}6.1.2 Schachteln versus Verketten{\textquotedbl} -- {\textquotedbl}6.1.3 Fluent Interface von jOOQ{\textquotedbl} -- {\textquotedbl}6.1.4 Ist der Aufwand gerechtfertigt?{\textquotedbl} -- {\textquotedbl}6.1.5 Fazit{\textquotedbl} -- {\textquotedbl}6.2 Template-Methoden{\textquotedbl} -- {\textquotedbl}6.2.1 API versus SPI{\textquotedbl} -- {\textquotedbl}6.2.2 Erweiterbare Parameter{\textquotedbl} -- {\textquotedbl}6.2.3 Fazit{\textquotedbl} -- {\textquotedbl}6.3 Callbacks{\textquotedbl} -- {\textquotedbl}6.3.1 Synchrone Callbacks{\textquotedbl} -- {\textquotedbl}6.3.2 Asynchrone Callbacks{\textquotedbl} -- {\textquotedbl}6.3.3 Fazit{\textquotedbl} -- {\textquotedbl}6.4 Annotationen{\textquotedbl} -- {\textquotedbl}6.4.1 Auswertung zum Kompilierzeitpunkt{\textquotedbl} -- {\textquotedbl}6.4.2 Auswertung zur Laufzeit{\textquotedbl} -- {\textquotedbl}6.4.3 Fazit{\textquotedbl} -- {\textquotedbl}6.5 Wrapper-Interfaces{\textquotedbl} -- {\textquotedbl}6.5.1 Proxy{\textquotedbl} -- {\textquotedbl}6.5.2 Adapter{\textquotedbl} -- {\textquotedbl}6.5.3 Fassade{\textquotedbl} -- {\textquotedbl}GeschÃ¤ftslogik zu Services orchestrieren{\textquotedbl} -- {\textquotedbl}AbhÃ¤ngigkeiten kapseln{\textquotedbl} -- {\textquotedbl}Abb. 6â2 Anti-Corruption Layer Ã¼bersetzt Modelle unterschiedlicher Bounded Contexts.{\textquotedbl} -- {\textquotedbl}6.5.4 Fazit{\textquotedbl} -- {\textquotedbl}6.6 Immutability{\textquotedbl} -- {\textquotedbl}6.6.1 Wiederverwendung{\textquotedbl} -- {\textquotedbl}6.6.2 Thread-Sicherheit{\textquotedbl} -- {\textquotedbl}6.6.3 Einfachheit

{\textquotedbl}6.6.4 Umsetzung{\textquotedbl} -- {\textquotedbl}6.6.5 Automatische ÃberprÃ¼fung mit dem Mutability Detector{\textquotedbl} -- {\textquotedbl}6.6.6 Codegenerierung mit Immutables{\textquotedbl} -- {\textquotedbl}6.6.7 Fazit{\textquotedbl} -- {\textquotedbl}6.7 Thread-sichere APIs{\textquotedbl} -- {\textquotedbl}6.7.1 Vorteile{\textquotedbl} -- {\textquotedbl}6.7.2 Nachteile{\textquotedbl} -- {\textquotedbl}6.7.3 Was bedeutet Thread-Sicherheit?{\textquotedbl} -- {\textquotedbl}6.7.4 Fazit{\textquotedbl} -- {\textquotedbl}6.8 Zusammenfassung{\textquotedbl} -- {\textquotedbl}7 KompatibilitÃ¤t von Java-APIs{\textquotedbl} -- {\textquotedbl}7.1 KompatibilitÃ¤tsstufen{\textquotedbl} -- {\textquotedbl}7.1.1 Code-KompatibilitÃ¤t{\textquotedbl} -- {\textquotedbl}7.1.2 BinÃ¤re KompatibilitÃ¤t{\textquotedbl} -- {\textquotedbl}Dynamisches Binden{\textquotedbl} -- {\textquotedbl}7.1.3 Funktionale KompatibilitÃ¤t{\textquotedbl} -- {\textquotedbl}AmÃ¶ben-Effekt{\textquotedbl} -- {\textquotedbl}Abb. 7â1 Das erwartete Verhalten der Applikation ist als perfekter Kreis dargestellt.{\textquotedbl} -- {\textquotedbl}Abb. 7â2 Das tatsÃ¤chlich implementierte Verhalten sieht so aus.{\textquotedbl} -- {\textquotedbl}Abb. 7â3 So kÃ¶nnte das Verhalten in der nÃ¤chsten Version aussehen.{\textquotedbl} -- {\textquotedbl}7.2 Verwandtschaftsbeziehungen{\textquotedbl} -- {\textquotedbl}Abb. 7â4 VorwÃ¤rts- und AbwÃ¤rtskompatibilitÃ¤t im Zusammenhang{\textquotedbl} -- {\textquotedbl}Nachteil der AbwÃ¤rtskompatibilitÃ¤t{\textquotedbl} -- {\textquotedbl}7.3 Design by Contract{\textquotedbl} -- {\textquotedbl}Tab. 7â1 VertragsÃ¤nderung aus Sicht des API-Implementierers und API-Aufrufers{\textquotedbl} -- {\textquotedbl}Ãnderung einer Methodenvorbedingung{\textquotedbl} -- {\textquotedbl}Ãnderung einer Methodennachbedingung{\textquotedbl} -- {\textquotedbl}Ãnderung einer Feldinvariante{\textquotedbl} -- {\textquotedbl}7.4 CodeÃ¤nderungen{\textquotedbl} -- {\textquotedbl}Varianzen{\textquotedbl} -- {\textquotedbl}7.4.1 Package-Ãnderungen{\textquotedbl} -- {\textquotedbl}7.4.2 Interface-Ãnderungen{\textquotedbl} -- {\textquotedbl}7.4.3 KlassenÃ¤nderungen{\textquotedbl} -- {\textquotedbl}7.4.4 Spezialisierung von RÃ¼ckgabetypen{\textquotedbl} -- {\textquotedbl}7.4.5 Generalisierung von Parametertypen{\textquotedbl} -- {\textquotedbl}7.4.6 Generics{\textquotedbl} -- {\textquotedbl}7.4.7 Ausnahmen{\textquotedbl} -- {\textquotedbl}7.4.8 Statische Methoden und Konstanten{\textquotedbl} -- {\textquotedbl}7.5 Praktische Techniken fÃ¼r API-Ãnderungen{\textquotedbl} -- {\textquotedbl}Missbilligung{\textquotedbl} -- {\textquotedbl}Delegation{\textquotedbl} -- {\textquotedbl}Namenskonventionen{\textquotedbl} -- {\textquotedbl}Defaultmethoden{\textquotedbl} -- {\textquotedbl}Laufzeitschalter{\textquotedbl} -- {\textquotedbl}Extension Interface{\textquotedbl} -- {\textquotedbl}Eingebaute Versionsinformationen{\textquotedbl} -- {\textquotedbl}7.6 Test Compatibility Kit{\textquotedbl} -- {\textquotedbl}Java Compatibility Kit{\textquotedbl} -- {\textquotedbl}SigTest{\textquotedbl} -- {\textquotedbl}7.7 Zusammenfassung{\textquotedbl} -- {\textquotedbl}Teil III â Remote-APIs{\textquotedbl} -- {\textquotedbl}8 Grundlagen RESTful HTTP{\textquotedbl} -- {\textquotedbl}8.1 REST versus HTTP

{\textquotedbl}8.2 REST-Grundprinzipien{\textquotedbl} -- {\textquotedbl}Eindeutige Identifikation von Ressourcen{\textquotedbl} -- {\textquotedbl}URI versus URL{\textquotedbl} -- {\textquotedbl}Verwendung von Hypermedia{\textquotedbl} -- {\textquotedbl}Verwendung von HTTP-Standardmethoden{\textquotedbl} -- {\textquotedbl}Tab. 8â1 RESTful HTTP fÃ¼r objektorientierte Schnittstelle{\textquotedbl} -- {\textquotedbl}Unterschiedliche ReprÃ¤sentationen von Ressourcen{\textquotedbl} -- {\textquotedbl}Medientypen (MIME-Types){\textquotedbl} -- {\textquotedbl}Statuslose Kommunikation{\textquotedbl} -- {\textquotedbl}8.3 Ressourcen â die zentralen Bausteine{\textquotedbl} -- {\textquotedbl}Ressourcen und ihre ReprÃ¤sentationen{\textquotedbl} -- {\textquotedbl}Abb. 8â1 Zusammenhang zwischen URI, ReprÃ¤sentation und abstrakter Ressource{\textquotedbl} -- {\textquotedbl}Ressourcenkategorien{\textquotedbl} -- {\textquotedbl}8.4 HTTP-Methoden{\textquotedbl} -- {\textquotedbl}GET{\textquotedbl} -- {\textquotedbl}HEAD{\textquotedbl} -- {\textquotedbl}PUT{\textquotedbl} -- {\textquotedbl}POST{\textquotedbl} -- {\textquotedbl}DELETE{\textquotedbl} -- {\textquotedbl}OPTIONS{\textquotedbl} -- {\textquotedbl}PATCH{\textquotedbl} -- {\textquotedbl}Zusammenfassung{\textquotedbl} -- {\textquotedbl}Tab. 8â2 Eigenschaften der HTTP-Methoden{\textquotedbl} -- {\textquotedbl}8.5 HATEOAS{\textquotedbl} -- {\textquotedbl}Fundamentale Unterschiede zu Remote Procedure Calls{\textquotedbl} -- {\textquotedbl}Dynamischer Workflow{\textquotedbl} -- {\textquotedbl}Affordance{\textquotedbl} -- {\textquotedbl}Hypertext Transfer Protocol{\textquotedbl} -- {\textquotedbl}Tab. 8â3 Bedeutung standardisierter Linkrelationen{\textquotedbl} -- {\textquotedbl}8.6 Zusammenfassung{\textquotedbl} -- {\textquotedbl}9 Techniken fÃ¼r Web-APIs{\textquotedbl} -- {\textquotedbl}9.1 Anwendungsbeispiel: Onlineshop{\textquotedbl} -- {\textquotedbl}Tab. 9â1 Zentrale Konzepte der Onlineshop-API{\textquotedbl} -- {\textquotedbl}Remote Procedure Calls vermeiden{\textquotedbl} -- {\textquotedbl}Tab. 9â2 Abbildung der fachlichen Aktionen auf HTTP-Methoden{\textquotedbl} -- {\textquotedbl}Ressourcen identifizieren{\textquotedbl} -- {\textquotedbl}Abb. 9â1 Initialer Entwurf: Die API des Onlineshops erlaubt die redaktionale Pflege der Produkte inklusive der Bilder und Bewertungen.{\textquotedbl} -- {\textquotedbl}GranularitÃ¤t beachten{\textquotedbl} -- {\textquotedbl}Abb. 9â2 Zweiter Entwurf: Bewertungen eines Produktes sind in separater Ressource.{\textquotedbl} -- {\textquotedbl}Konsistenz sicherstellen{\textquotedbl} -- {\textquotedbl}Abb. 9â3 Dritter Entwurf: Bilder werden in separaten Ressourcen gepflegt und von den Produkt- beschreibungen referenziert. Links auf Templates zur Erstellung von Produkten und Bewertungen sind nicht eingezeichnet.{\textquotedbl} -- {\textquotedbl}Fachliche Transaktionen{\textquotedbl} -- {\textquotedbl}Homepage-Ressource anbieten

{\textquotedbl}Abb. 9{\^a}4 Vierter Entwurf: Die Interaktion beginnt mit den von der Homepage-Ressource bereitgestellten Links},
 author = {Spichale, Kai},
 year = {2017},
 title = {API-Design: Praxishandbuch f{\"u}r Java- und Webservice-Entwickler},
 url = {http://proquestcombo.safaribooksonline.com/9781492020103},
 keywords = {API;Java;Softwareentwicklung;Verteiltes System;Web Services},
 address = {Heidelberg},
 publisher = {dpunkt.verlag},
 isbn = {9783864903878},
 file = {https://ebookcentral.proquest.com/lib/gbv/detail.action?docID=5102100},
 file = {https://external.dandelon.com/download/attachments/dandelon/ids/DE0011EAEEA9B72BEFB05C12580AA003E9D13.pdf}
}


@book{Walls.20162017,
 author = {Walls, Craig and Carnell, John},
 year = {2016 // 2017},
 title = {Spring Boot in action // Spring microservices in action},
 url = {https://www.nitinagrawal.com/uploads/2/1/3/6/21361954/spring_boot_in_action.pdf},
 address = {Shelter Island},
 publisher = {Manning and {Manning Publications Co}},
 isbn = {978-1-61729-398-6}
}


